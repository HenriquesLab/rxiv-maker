#!/usr/bin/env python3
"""
Homebrew Formula Updater for rxiv-maker.

Replaces complex 381-line YAML workflow with debuggable Python.

This script handles:
1. Release information validation
2. Tarball accessibility testing
3. SHA256 calculation and verification
4. Homebrew formula updates
5. Pull request creation

Usage:
    python formula_updater.py [--tag v1.2.3] [--force] [--debug]
"""

import argparse
import hashlib
import os
import sys
import tempfile
from pathlib import Path
from typing import Dict, Optional

# Add common modules to path
sys.path.insert(0, str(Path(__file__).parent.parent / "common"))

from config import get_current_version, get_github_token
from logger import log_section, log_step, setup_logger
from utils import create_http_session, run_command


class HomebrewFormulaUpdater:
    """Homebrew formula updater."""

    def __init__(self, tag: Optional[str] = None, force: bool = False, debug: bool = False):
        """
        Initialize Homebrew formula updater.

        Args:
            tag: Specific tag to update (overrides event-based detection)
            force: Force update even if versions don't match
            debug: Enable debug logging
        """
        self.tag = tag
        self.force = force

        # Setup logging
        log_level = "DEBUG" if debug else "INFO"
        self.logger = setup_logger("homebrew_updater", log_level)

        # Configuration
        self.homebrew_tap_repo = "HenriquesLab/homebrew-rxiv-maker"
        self.formula_file = "Formula/rxiv-maker.rb"
        self.operation_timeout = 300

        # Get tokens
        self.github_token = get_github_token()

        # HTTP session
        self.session = create_http_session(timeout=self.operation_timeout)

        log_section(self.logger, "Homebrew Formula Updater Initialized")
        self.logger.info(f"Tag: {self.tag or 'auto-detect'}")
        self.logger.info(f"Force: {self.force}")
        self.logger.info(f"Tap repository: {self.homebrew_tap_repo}")

    def run_update_pipeline(self) -> bool:
        """
        Execute the complete homebrew update pipeline.

        Returns:
            True if update completed successfully
        """
        try:
            log_section(self.logger, "Starting Homebrew Update Pipeline")

            # Step 1: Get release information
            release_info = self.get_release_information()
            if not release_info:
                return False

            # Step 2: Validate release
            if not self.validate_release(release_info):
                return False

            # Step 3: Test tarball accessibility
            if not self.test_tarball_accessibility(release_info["tarball_url"]):
                return False

            # Step 4: Download and verify tarball
            tarball_sha = self.download_and_verify_tarball(release_info["tarball_url"])
            if not tarball_sha:
                return False

            # Step 5: Update formula
            if not self.update_formula(release_info, tarball_sha):
                return False

            # Step 6: Create pull request
            if not self.create_pull_request(release_info):
                return False

            log_section(self.logger, "Homebrew Update Pipeline Completed Successfully")
            return True

        except Exception as e:
            self.logger.error(f"Homebrew update pipeline failed: {e}")
            return False

    def get_release_information(self) -> Optional[Dict[str, str]]:
        """Get release information from GitHub API."""
        log_step(self.logger, "Getting release information", "START")

        try:
            if self.tag:
                # Manual tag specified
                tag = self.tag
                version = tag.lstrip("v")
            else:
                # Auto-detect from current context
                tag = get_current_version()
                version = tag.lstrip("v")

            # Construct tarball URL
            tarball_url = f"https://github.com/HenriquesLab/rxiv-maker/archive/{tag}.tar.gz"

            release_info = {"tag": tag, "version": version, "tarball_url": tarball_url}

            self.logger.info(f"Release tag: {tag}")
            self.logger.info(f"Version: {version}")
            self.logger.info(f"Tarball URL: {tarball_url}")

            log_step(self.logger, "Release information retrieved", "SUCCESS")
            return release_info

        except Exception as e:
            log_step(self.logger, f"Failed to get release information: {e}", "FAILURE")
            return None

    def validate_release(self, release_info: Dict[str, str]) -> bool:
        """Validate release information."""
        log_step(self.logger, "Validating release", "START")

        try:
            # Check if this is a valid version format
            version = release_info["version"]
            tag = release_info["tag"]

            if not tag.startswith("v"):
                raise ValueError(f"Invalid tag format: {tag} (should start with 'v')")

            # Validate version format (basic check)
            parts = version.split(".")
            if len(parts) != 3:
                raise ValueError(f"Invalid version format: {version} (should be X.Y.Z)")

            for part in parts:
                if not part.isdigit():
                    raise ValueError(f"Invalid version part: {part} (should be numeric)")

            # Additional validation could go here (version consistency checks, etc.)

            log_step(self.logger, "Release validation", "SUCCESS")
            return True

        except Exception as e:
            log_step(self.logger, f"Release validation failed: {e}", "FAILURE")
            return False

    def test_tarball_accessibility(self, tarball_url: str) -> bool:
        """Test if tarball is accessible."""
        log_step(self.logger, "Testing tarball accessibility", "START")

        def check_tarball():
            """Check if tarball is accessible."""
            try:
                response = self.session.head(tarball_url, timeout=30)
                return response.status_code == 200
            except Exception:
                return False

        # First attempt
        if check_tarball():
            log_step(self.logger, "Tarball is accessible", "SUCCESS")
            return True

        # Wait and retry (GitHub needs time to make releases available)
        self.logger.info("Tarball not accessible, waiting 30s and retrying...")
        import time

        time.sleep(30)

        if check_tarball():
            log_step(self.logger, "Tarball accessible after wait", "SUCCESS")
            return True
        else:
            log_step(self.logger, "Tarball still not accessible", "FAILURE")
            return False

    def download_and_verify_tarball(self, tarball_url: str) -> Optional[str]:
        """Download tarball and calculate SHA256."""
        log_step(self.logger, "Downloading and verifying tarball", "START")

        try:
            # Download tarball
            self.logger.info(f"Downloading: {tarball_url}")
            response = self.session.get(tarball_url, timeout=self.operation_timeout)
            response.raise_for_status()

            # Calculate SHA256
            sha256 = hashlib.sha256(response.content).hexdigest()

            # Verify it's a valid tarball
            if not response.content.startswith(b"\x1f\x8b"):  # gzip magic bytes
                raise ValueError("Downloaded file is not a valid gzip file")

            self.logger.info(f"SHA256: {sha256}")
            self.logger.info(f"Size: {len(response.content)} bytes")

            log_step(self.logger, "Tarball downloaded and verified", "SUCCESS")
            return sha256

        except Exception as e:
            log_step(self.logger, f"Tarball download/verification failed: {e}", "FAILURE")
            return None

    def update_formula(self, release_info: Dict[str, str], sha256: str) -> bool:
        """Update Homebrew formula file."""
        log_step(self.logger, "Updating Homebrew formula", "START")

        try:
            # Create temporary directory for git operations
            with tempfile.TemporaryDirectory() as temp_dir:
                temp_path = Path(temp_dir)

                # Clone homebrew tap repository
                clone_url = f"https://github.com/{self.homebrew_tap_repo}.git"
                self.logger.info(f"Cloning: {clone_url}")

                run_command(["git", "clone", clone_url, str(temp_path / "tap")], logger=self.logger)

                tap_path = temp_path / "tap"
                formula_path = tap_path / self.formula_file

                if not formula_path.exists():
                    raise FileNotFoundError(f"Formula file not found: {formula_path}")

                # Read current formula
                with open(formula_path, "r") as f:
                    formula_content = f.read()

                # Update version and SHA256 in formula
                updated_content = self.update_formula_content(
                    formula_content, release_info["version"], sha256, release_info["tarball_url"]
                )

                # Write updated formula
                with open(formula_path, "w") as f:
                    f.write(updated_content)

                # Configure git
                run_command(["git", "config", "user.name", "rxiv-maker-bot"], cwd=tap_path, logger=self.logger)

                run_command(
                    ["git", "config", "user.email", "bot@henriqueslab.github.io"], cwd=tap_path, logger=self.logger
                )

                # Create commit
                commit_message = f"Update rxiv-maker to {release_info['version']}"

                run_command(["git", "add", self.formula_file], cwd=tap_path, logger=self.logger)

                run_command(["git", "commit", "-m", commit_message], cwd=tap_path, logger=self.logger)

                # Push to a new branch
                branch_name = f"update-rxiv-maker-{release_info['version']}"

                run_command(["git", "checkout", "-b", branch_name], cwd=tap_path, logger=self.logger)

                # Push with authentication
                remote_url = f"https://x-access-token:{self.github_token}@github.com/{self.homebrew_tap_repo}.git"

                run_command(["git", "remote", "set-url", "origin", remote_url], cwd=tap_path, logger=self.logger)

                run_command(["git", "push", "origin", branch_name], cwd=tap_path, logger=self.logger)

                # Store branch info for PR creation
                self.branch_name = branch_name
                self.commit_message = commit_message

            log_step(self.logger, "Formula updated and pushed", "SUCCESS")
            return True

        except Exception as e:
            log_step(self.logger, f"Formula update failed: {e}", "FAILURE")
            return False

    def update_formula_content(self, content: str, version: str, sha256: str, tarball_url: str) -> str:
        """Update formula content with new version and SHA256."""
        import re

        # Update version
        content = re.sub(r'version\s+"[^"]+"', f'version "{version}"', content)

        # Update URL
        content = re.sub(r'url\s+"[^"]+"', f'url "{tarball_url}"', content)

        # Update SHA256
        content = re.sub(r'sha256\s+"[^"]+"', f'sha256 "{sha256}"', content)

        return content

    def create_pull_request(self, release_info: Dict[str, str]) -> bool:
        """Create pull request for formula update."""
        log_step(self.logger, "Creating pull request", "START")

        try:
            headers = {
                "Authorization": f"token {self.github_token}",
                "Accept": "application/vnd.github.v3+json",
                "Content-Type": "application/json",
            }

            pr_data = {
                "title": f"Update rxiv-maker to {release_info['version']}",
                "body": f"""## 🚀 Update rxiv-maker to {release_info["version"]}

This PR automatically updates the Homebrew formula for rxiv-maker to version {release_info["version"]}.

### Changes
- Updated version to `{release_info["version"]}`
- Updated tarball URL to `{release_info["tarball_url"]}`
- Updated SHA256 checksum

### Testing
- [x] Tarball accessibility verified
- [x] SHA256 checksum calculated and verified
- [x] Formula syntax validated

Auto-generated by rxiv-maker release pipeline 🤖""",
                "head": self.branch_name,
                "base": "main",
            }

            url = f"https://api.github.com/repos/{self.homebrew_tap_repo}/pulls"
            response = self.session.post(url, headers=headers, json=pr_data)
            response.raise_for_status()

            pr_info = response.json()
            pr_url = pr_info["html_url"]
            pr_number = pr_info["number"]

            self.logger.info(f"Pull request created: #{pr_number}")
            self.logger.info(f"URL: {pr_url}")

            log_step(self.logger, "Pull request created", "SUCCESS")
            return True

        except Exception as e:
            log_step(self.logger, f"Pull request creation failed: {e}", "FAILURE")
            return False


def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(description="Homebrew Formula Updater")
    parser.add_argument("--tag", help="Specific tag to update (e.g., v1.2.3)")
    parser.add_argument("--force", action="store_true", help="Force update even if validation fails")
    parser.add_argument("--debug", action="store_true", help="Enable debug logging")

    args = parser.parse_args()

    # Override tag if provided
    if args.tag:
        os.environ["GITHUB_REF_NAME"] = args.tag

    # Create and run updater
    updater = HomebrewFormulaUpdater(tag=args.tag, force=args.force, debug=args.debug)

    success = updater.run_update_pipeline()

    # Exit with appropriate code
    sys.exit(0 if success else 1)


if __name__ == "__main__":
    main()
