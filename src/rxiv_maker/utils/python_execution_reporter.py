"""Python execution reporting utility for rxiv-maker.

This module provides centralized reporting of Python code execution during manuscript
build process, including code blocks executed, outputs generated, and any errors encountered.
"""

import datetime
import re
from typing import Any, Dict, List, Optional, Tuple


class PythonExecutionEntry:
    """Represents a single Python execution event."""

    def __init__(
        self,
        entry_type: str,
        code: str = "",
        output: str = "",
        line_number: Optional[int] = None,
        file_path: str = "manuscript",
        variable_name: str = "",
        variable_value: Any = None,
        error_message: str = "",
        execution_time: Optional[float] = None
    ):
        """Initialize a Python execution entry.

        Args:
            entry_type: Type of entry ('exec', 'get', 'inline', 'error')
            code: Python code that was executed
            output: Output generated by the code
            line_number: Line number in the source file
            file_path: Source file path
            variable_name: Name of variable (for 'get' type)
            variable_value: Value of variable (for 'get' type)
            error_message: Error message if execution failed
            execution_time: Time taken for execution in seconds
        """
        self.entry_type = entry_type
        self.code = code
        self.output = output
        self.line_number = line_number
        self.file_path = file_path
        self.variable_name = variable_name
        self.variable_value = variable_value
        self.error_message = error_message
        self.execution_time = execution_time
        self.timestamp = datetime.datetime.now()


class PythonExecutionReporter:
    """Singleton class to collect and report Python execution during manuscript build."""

    _instance = None
    _initialized = False

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super(PythonExecutionReporter, cls).__new__(cls)
        return cls._instance

    def __init__(self):
        if not self._initialized:
            self.entries: List[PythonExecutionEntry] = []
            self.build_start_time = datetime.datetime.now()
            self._initialized = True

    @classmethod
    def get_instance(cls) -> 'PythonExecutionReporter':
        """Get the singleton instance of the reporter."""
        return cls()

    def reset(self) -> None:
        """Reset the reporter for a new build process."""
        self.entries.clear()
        self.build_start_time = datetime.datetime.now()

    def track_exec_block(
        self,
        code: str,
        output: str,
        line_number: Optional[int] = None,
        file_path: str = "manuscript",
        execution_time: Optional[float] = None
    ) -> None:
        """Track execution of a {{py:exec}} block.

        Args:
            code: Python code that was executed
            output: Output generated by the code
            line_number: Line number where the block starts
            file_path: Source file containing the block
            execution_time: Time taken for execution in seconds
        """
        entry = PythonExecutionEntry(
            entry_type="exec",
            code=code,
            output=output,
            line_number=line_number,
            file_path=file_path,
            execution_time=execution_time
        )
        self.entries.append(entry)

    def track_get_variable(
        self,
        variable_name: str,
        variable_value: Any,
        line_number: Optional[int] = None,
        file_path: str = "manuscript"
    ) -> None:
        """Track a {{py:get}} variable access.

        Args:
            variable_name: Name of the variable being accessed
            variable_value: Value of the variable
            line_number: Line number where the access occurs
            file_path: Source file containing the access
        """
        entry = PythonExecutionEntry(
            entry_type="get",
            variable_name=variable_name,
            variable_value=variable_value,
            line_number=line_number,
            file_path=file_path
        )
        self.entries.append(entry)

    def track_inline_execution(
        self,
        code: str,
        output: str,
        line_number: Optional[int] = None,
        file_path: str = "manuscript",
        execution_time: Optional[float] = None
    ) -> None:
        """Track execution of a {{py:}} inline block.

        Args:
            code: Python code that was executed
            output: Output generated by the code
            line_number: Line number where the block occurs
            file_path: Source file containing the block
            execution_time: Time taken for execution in seconds
        """
        entry = PythonExecutionEntry(
            entry_type="inline",
            code=code,
            output=output,
            line_number=line_number,
            file_path=file_path,
            execution_time=execution_time
        )
        self.entries.append(entry)

    def track_error(
        self,
        error_message: str,
        code_snippet: str = "",
        line_number: Optional[int] = None,
        file_path: str = "manuscript"
    ) -> None:
        """Track a Python execution error.

        Args:
            error_message: Error message that occurred
            code_snippet: Code that caused the error
            line_number: Line number where the error occurred
            file_path: Source file where the error occurred
        """
        entry = PythonExecutionEntry(
            entry_type="error",
            code=code_snippet,
            error_message=error_message,
            line_number=line_number,
            file_path=file_path
        )
        self.entries.append(entry)

    def has_python_activity(self) -> bool:
        """Check if any Python code was executed during the build."""
        return len(self.entries) > 0

    def get_execution_summary(self) -> Dict[str, Any]:
        """Get a summary of Python execution statistics.

        Returns:
            Dictionary containing execution statistics
        """
        summary = {
            "total_entries": len(self.entries),
            "exec_blocks": len([e for e in self.entries if e.entry_type == "exec"]),
            "get_variables": len([e for e in self.entries if e.entry_type == "get"]),
            "inline_blocks": len([e for e in self.entries if e.entry_type == "inline"]),
            "errors": len([e for e in self.entries if e.entry_type == "error"]),
            "build_start_time": self.build_start_time,
            "has_errors": any(e.entry_type == "error" for e in self.entries)
        }

        # Calculate total execution time
        execution_times = [e.execution_time for e in self.entries if e.execution_time is not None]
        summary["total_execution_time"] = sum(execution_times) if execution_times else None

        return summary

    def _escape_latex(self, text: str) -> str:
        """Escape special LaTeX characters in text.

        Args:
            text: Text to escape

        Returns:
            LaTeX-safe text
        """
        # Basic LaTeX escaping
        replacements = {
            '\\': r'\textbackslash{}',
            '{': r'\{',
            '}': r'\}',
            '$': r'\$',
            '&': r'\&',
            '%': r'\%',
            '#': r'\#',
            '^': r'\textasciicircum{}',
            '_': r'\_',
            '~': r'\textasciitilde{}'
        }

        result = text
        for char, replacement in replacements.items():
            result = result.replace(char, replacement)

        return result

    def _format_code_for_latex(self, code: str, max_lines: int = 20) -> str:
        """Format Python code for LaTeX verbatim display.

        Args:
            code: Python code to format
            max_lines: Maximum number of lines to show

        Returns:
            LaTeX-formatted code
        """
        lines = code.strip().split('\n')

        if len(lines) > max_lines:
            displayed_lines = lines[:max_lines]
            displayed_lines.append(f"... ({len(lines) - max_lines} more lines)")
            code = '\n'.join(displayed_lines)

        return code

    def _format_output_for_latex(self, output: str, max_lines: int = 10) -> str:
        """Format Python output for LaTeX verbatim display.

        Args:
            output: Python output to format
            max_lines: Maximum number of lines to show

        Returns:
            LaTeX-formatted output
        """
        if not output.strip():
            return "(no output)"

        lines = output.strip().split('\n')

        if len(lines) > max_lines:
            displayed_lines = lines[:max_lines]
            displayed_lines.append(f"... ({len(lines) - max_lines} more lines)")
            output = '\n'.join(displayed_lines)

        return output

    def generate_latex_section(self) -> str:
        """Generate a LaTeX section documenting Python code execution.

        Returns:
            LaTeX code for the Python execution section
        """
        if not self.has_python_activity():
            return ""

        summary = self.get_execution_summary()

        latex_content = []

        # Section header
        latex_content.append(r"\section*{Python Code Execution Report}")
        latex_content.append(r"\addcontentsline{toc}{section}{Python Code Execution Report}")
        latex_content.append("")

        # Summary
        latex_content.append(r"This section provides a comprehensive report of Python code execution that occurred during manuscript compilation.")
        latex_content.append("")

        # Statistics
        latex_content.append(r"\subsection*{Execution Summary}")
        build_time_str = self.build_start_time.strftime("%Y-%m-%d %H:%M:%S")
        latex_content.append(rf"Build timestamp: \texttt{{{build_time_str}}}")
        latex_content.append(rf"Total Python operations: {summary['total_entries']}")
        latex_content.append(rf"Initialization blocks (\texttt{{{{py:exec}}}}): {summary['exec_blocks']}")
        latex_content.append(rf"Variable retrievals (\texttt{{{{py:get}}}}): {summary['get_variables']}")
        latex_content.append(rf"Inline executions (\texttt{{{{py:}}}}): {summary['inline_blocks']}")

        if summary['total_execution_time'] is not None:
            latex_content.append(rf"Total execution time: {summary['total_execution_time']:.3f} seconds")

        if summary['errors'] > 0:
            latex_content.append(rf"\textcolor{{red}}{{Errors encountered: {summary['errors']}}}")

        latex_content.append("")

        # Execution blocks details
        exec_entries = [e for e in self.entries if e.entry_type == "exec"]
        if exec_entries:
            latex_content.append(r"\subsection*{Initialization Blocks}")
            latex_content.append(r"The following \texttt{{\{py:exec\}}} blocks were executed to initialize the Python environment:")
            latex_content.append("")

            for i, entry in enumerate(exec_entries, 1):
                line_info = f" (line {entry.line_number})" if entry.line_number else ""
                latex_content.append(rf"\textbf{{Block {i}{line_info}:}}")
                latex_content.append(r"\begin{lstlisting}[language=Python,basicstyle=\footnotesize\ttfamily]")
                latex_content.append(self._format_code_for_latex(entry.code))
                latex_content.append(r"\end{lstlisting}")

                if entry.output.strip():
                    latex_content.append(r"\textbf{Output:}")
                    latex_content.append(r"\begin{verbatim}")
                    latex_content.append(self._format_output_for_latex(entry.output))
                    latex_content.append(r"\end{verbatim}")

                latex_content.append("")

        # Variable access details
        get_entries = [e for e in self.entries if e.entry_type == "get"]
        if get_entries:
            latex_content.append(r"\subsection*{Variable Retrievals}")
            latex_content.append(r"The following variables were retrieved using \texttt{{\{py:get\}}} commands:")
            latex_content.append("")

            # Group by variable name
            var_groups: Dict[str, List[PythonExecutionEntry]] = {}
            for entry in get_entries:
                if entry.variable_name not in var_groups:
                    var_groups[entry.variable_name] = []
                var_groups[entry.variable_name].append(entry)

            latex_content.append(r"\begin{itemize}")
            for var_name, entries in var_groups.items():
                # Show the variable name and its most recent value
                latest_entry = max(entries, key=lambda e: e.timestamp)
                value_str = str(latest_entry.variable_value)
                if len(value_str) > 50:
                    value_str = value_str[:47] + "..."

                access_count = len(entries)
                count_str = f" ({access_count} times)" if access_count > 1 else ""

                latex_content.append(rf"\item \texttt{{{var_name}}}{count_str}: \texttt{{{self._escape_latex(value_str)}}}")
            latex_content.append(r"\end{itemize}")
            latex_content.append("")

        # Error details
        error_entries = [e for e in self.entries if e.entry_type == "error"]
        if error_entries:
            latex_content.append(r"\subsection*{Errors and Warnings}")
            latex_content.append(r"\textcolor{red}{The following errors occurred during Python execution:}")
            latex_content.append("")

            for i, entry in enumerate(error_entries, 1):
                line_info = f" (line {entry.line_number})" if entry.line_number else ""
                latex_content.append(rf"\textbf{{Error {i}{line_info}:}}")

                if entry.code.strip():
                    latex_content.append(r"\textbf{Code:}")
                    latex_content.append(r"\begin{verbatim}")
                    latex_content.append(self._format_code_for_latex(entry.code, max_lines=5))
                    latex_content.append(r"\end{verbatim}")

                latex_content.append(r"\textbf{Error message:}")
                latex_content.append(r"\begin{verbatim}")
                latex_content.append(entry.error_message)
                latex_content.append(r"\end{verbatim}")
                latex_content.append("")

        # Footer
        latex_content.append(r"\vspace{0.5cm}")
        latex_content.append(r"\textit{This report was automatically generated by rxiv-maker during manuscript compilation.}")

        return "\n".join(latex_content)


# Global instance for easy access
_global_reporter: Optional[PythonExecutionReporter] = None


def get_python_execution_reporter() -> PythonExecutionReporter:
    """Get the global Python execution reporter instance."""
    global _global_reporter
    if _global_reporter is None:
        _global_reporter = PythonExecutionReporter()
    return _global_reporter


def reset_python_execution_reporter() -> None:
    """Reset the global Python execution reporter for a new build."""
    global _global_reporter
    if _global_reporter is not None:
        _global_reporter.reset()